type Bool {                 -- CE2: include prelude
    False: ()
    True:  ()
}

func not: Bool -> Bool {
    if arg {
        return False
    } else {
        return True
    }
}

func and: (Bool,Bool) -> Bool {
    if arg.1 {
        return arg.2
    } else {
        return False
    }
}

func or: (Bool,Bool) -> Bool {
    if arg.1 {
        return True
    } else {
        return arg.2
    }
}

func asbool: Int -> Bool {
    return _(arg ? (Bool){True} : (Bool){False})
}

-------------------------------------------------------------------------------

native pre _{
    #include <string.h>
    #include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

native _{
    typedef enum {
        TK_ERR = 0,

        TK_SINGLE = 256,   // all single-char tokens

        TK_EOF,
        TK_ARROW,
        TK_UNIT,

        TX_NAT,
        TX_VAR,
        TX_EMPTY,
        TX_USER,
        TX_NUM,

        TK_RESERVED,    // all reserved keywords
        //TK_ARG,
        TK_BREAK,
        TK_CALL,
        //TK_CLONE,
        TK_ELSE,
        TK_FUNC,
        TK_IF,
        TK_INPUT,
        TK_LOOP,
        TK_NAT,
        TK_OUTPUT,
        TK_PRE,
        TK_REC,
        TK_RET,
        TK_SET,
        TK_TYPE,
        TK_VAR
    } TK;
}

native _{
    static char* reserved[] = {
        //"arg",
        "break",
        "call",
        //"clone",
        "else",
        "func",
        "if",
        "input",
        //"Int",
        "loop",
        "native",
        "output",
        "pre",
        "rec",
        "return",
        "set",
        //"Std",
        "type",
        "var"
    };
}

native _{
    #define ERR_BUF 256
    #define TK_BUF 1024
    typedef char Str_Buf[TK_BUF];
    typedef char Err_Buf[ERR_BUF];
    typedef char* String;
    typedef FILE* FILE_PTR;
}

type TK_Val {
    Num: Int
    Str: _Str_Buf
}

func is_reserved: \TK_Val -> Int {
    var n: Int = _(sizeof(reserved) / sizeof(reserved[0]))
    var i: Int = 0
    loop {
        var str: _(char*) = arg\.Str!
        if asbool _(!strcmp(str, reserved[i])) {
            return _(TK_RESERVED+1 + i)
        }
        set i = _(i + 1)
        if asbool _(i == n) {
            break
        }
    }
    return 0;
}

var fout: _(FILE*) = ?
var finp: _(FILE*) = ?
var lin: Int = ?
var col: Int = ?
var tk0: (Int,TK_Val,Int,Int) = ?   -- enu, val, lin, col   // CE2: typedef
var tk1: (Int,TK_Val,Int,Int) = ?   -- enu, val, lin, col
var err: _Err_Buf = ?

-------------------------------------------------------------------------------

func lexer_tk2err: Int -> _(const char*) {
    native _{ static char str[512]; }
    if asbool _(arg == TK_EOF) {
        native _{ strcpy(str, "end of file"); }
        return _str
    }
    if asbool _(arg == TX_NAT) {
        native _{ strcpy(str, "`_{...}´"); }
        return _str
    }
    if asbool _(arg == TX_VAR) {
        native _{ strcpy(str, "variable identifier"); }
        return _str
    }
    if asbool _(arg == TX_USER) {
        native _{ strcpy(str, "type identifier"); }
        return _str
    }
    if asbool _(arg == TX_NUM) {
        native _{ strcpy(str, "tuple index"); }
        return _str
    }
    if asbool _(arg>0 && arg<TK_SINGLE) {
        native _{ sprintf(str, "`%c´", arg); }
        return _str
    }
    call _assert 0
}

func lexer_tk2str: (Int,TK_Val,Int,Int) -> _(const char*) {
    native _{ static char str[TK_BUF+256]; }
    if asbool _(arg._1 == TK_EOF) {
        native _{ sprintf(str, "end of file"); }
        return _str
    }
    if asbool _(arg._1 == TK_UNIT) {
        native _{ sprintf(str, "`()´"); }
        return _str
    }
    if asbool _(arg._1 == TX_NAT) {
        native _{ sprintf(str, "\"_%s\"", arg._2._Str); }
        return _str
    }
    if asbool _(arg._1 == TX_NUM) {
        native _{ sprintf(str, "\"%d\"", arg._2._Num); }
        return _str
    }
    if asbool _(arg._1==TX_VAR || arg._1==TX_USER || arg._1==TX_EMPTY || arg._1==TK_ERR) {
        native _{ sprintf(str, "\"%s\"", arg._2._Str); }
        return _str
    }
    if asbool _(arg._1>0 && arg._1<TK_SINGLE) {
        native _{ sprintf(str, "`%c´", arg._1); }
        return _str
    }
    if asbool _(arg._1 > TK_RESERVED) {
        native _{ sprintf(str, "`%s´", reserved[arg._1-TK_RESERVED-1]); }
        return _str
    }
    call _assert 0
}

func lx_blanks: () -> () {
    loop {
        var c: Int = call _fgetc finp
        if asbool _(c == '-') {
            set c = call _fgetc finp
            if asbool _(c == '-') {                 -- ignore comments
                set col = _(col + 1)
                set col = _(col + 1)
                loop {
                    set c = call _fgetc finp
                    if asbool _(c == EOF) {         -- EOF stops comment
                        break
                    }
                    if asbool _(c == '\n') {        -- LN stops comment
                        native _(ungetc(c, finp);)
                        break
                    }
                    set col = _(col + 1)
                }
            } else {
                native _(ungetc(c, finp);)
                native _(ungetc('-', finp);)
                return ()
            }
        } else {
            if asbool _(c == '\n') {                -- ignore new lines
                set lin = _(lin + 1)
                set col = 1
            } else {
                if asbool _(c == ' ') {             -- ignore new spaces
                    set col = _(col + 1)
                } else {
                    native _(ungetc(c, finp);)
                    return ()
                }
            }
        }
    }
}

func lx_token: () -> () {
    var c: Int = call _fgetc finp

    -- SYMBOLS
    if asbool _{c=='{' || c=='}' || c==')'  || c==';' || c==':' || c=='=' ||
                c==',' || c=='.' || c=='\\' || c=='!' || c=='?'}
    {
        set tk1.1 = c
        return ()
    }

    -- EOF
    if asbool _(c == EOF) {
        set tk1.1 = _TK_EOF
        return ()
    }

    -- '(', TK_UNIT
    if asbool _{c == '('} {
        set c = call _fgetc finp
        if asbool _{c == ')'} {
            set tk1.2 = Str ?
            native _{strcpy(tk1._2._Str, "()");}
            set tk1.1 = _TK_UNIT
            return ()
        }
        native _(ungetc(c, finp);)
        set tk1.1 = _{'('}
        return ()
    }

    -- TK_ARROW
    if asbool _(c == '-') {
        set c = call _fgetc finp
        if asbool _(c == '>') {
            set tk1.1 = _TK_ARROW
            return ()
        }
        call _assert 0
    }

    -- TX_NAT
    if asbool _(c == '_') {
        set c = call _fgetc finp
        var open: Int = 0
        var close: Int = 0
        var open_close: Int = 0
        if asbool _(c=='(' /*)*/ || c=='{') {
            set open  = c;
            if asbool _{c == '('} {
                set close = _{')'}
            } else {
                set close = _('}')
            }
            set c = call _fgetc finp
            set open_close = _(open_close + 1)
        }

        var i: Int = 0
        loop {
            if asbool _(!close && !isalnum(c) && c!='_') {
                break
            }
            if asbool _(c == open) {
                set open_close = _(open_close + 1)
            } else {
                if asbool _(c == close) {
                    set open_close = _(open_close - 1)
                    if asbool _(open_close == 0) {
                        break;
                    }
                }
            }
            native _{ tk1._2._Str[i] = c; }
            set i = _(i + 1)
            if asbool _(c == '\n') {
                set lin = _(lin + 1)
            }
            set c = call _fgetc finp
            call _assert _(i < TK_BUF)
        }

        native _{ tk1._2._Str[i] = '\0'; }
        if asbool _(!close) {
            native _(ungetc(c, finp);)
        }

        set tk1.1 = _TX_NAT
        return ()
    }

    set tk1.2 = Str ?

    -- TX_NUM
    if asbool _(isdigit(c)) {
        var i: Int = 0
        loop {
            if asbool _(!isalnum(c)) {
                break
            }
            if asbool _(isdigit(c)) {
                native _{ tk1._2._Str[i] = c; }
                set i = _(i + 1)
                call _assert _(i < TK_BUF)
            } else {
                native _{ tk1._2._Str[i] = '\0'; }
                set tk1.1 = _TK_ERR
                return ()
            }
            set c = call _fgetc finp
        }
        native _{ tk1._2._Str[i] = '\0'; }
        set tk1.2 = Num _atoi tk1.2.Str!
        native _(ungetc(c, finp);)
        set tk1.1 = _TX_NUM
        return ()
    }

    -- TX_EMPTY, TX_VAR, TX_USER
    var isdollar: Bool = asbool _(c == '$')
    if isdollar {
        set c = call _fgetc finp
        if asbool _(!isupper(c)) {
            native _{ tk1._2._Str[0] = '$'; }
            native _{ tk1._2._Str[1] = c; }
            native _{ tk1._2._Str[2] = '\0'; }
            set tk1.1 = _TK_ERR
            return ()
        }
    }
    if asbool _(isalpha(c)) {
        var i: Int = 0
        loop {
            if asbool _(!isalnum(c) && c!='_') {
                break
            }
            native _{ tk1._2._Str[i] = c; }
            set i = _(i + 1)
            call _assert _(i < TK_BUF)
            set c = call _fgetc finp
        }
        native _{ tk1._2._Str[i] = '\0'; }
        native _(ungetc(c, finp);)

        var key: Int = call is_reserved(\tk1.2)
        if asbool _(key != 0) {
            set tk1.1 = key
            return ()
        }

        -- TX_EMPTY
        if isdollar {
            set tk1.1 = _TX_EMPTY
            return ()
        }

        -- TX_VAR
        if asbool _(islower(tk1._2._Str[0])) {
            set tk1.1 = _TX_VAR
            return ()
        }

        -- TX_USER
        if asbool _(isupper(tk1._2._Str[0])) {
            set tk1.1 = _TX_USER
            return ()
        }

        call _assert 0
    }

    call _assert 0
}

func lexer: () -> () {
    set tk0 = tk1
    call lx_blanks ()
    set tk1.3 = lin
    set tk1.4 = col
    var bef: Int = call _ftell finp
    call lx_token  ()
    set col = _(col + (ftell(finp) - bef))
    call lx_blanks ()
}

-------------------------------------------------------------------------------

func err_tk: ((Int,TK_Val,Int,Int),_String) -> () {
    native _{ sprintf(err, "(ln %d, col %d): %s",
        arg._1._3, arg._1._4, arg._2); }
}

func err_expected: _(const char*) -> () {
    native _{ sprintf(err, "(ln %d, col %d): expected %s : have %s",
        tk1._3, tk1._4, arg, lexer_tk2str(tk1)); }
}

func accept: _TK -> Bool {
    if asbool _(tk1._1 == arg) {
        call lexer ()
        return True
    } else {
        return False
    }
}

func accept_err: _TK -> Bool {
    var ret: Bool = accept(arg);
    if not ret {
        call err_expected _(lexer_tk2err(arg))
    }
    return ret
}

func check: _TK -> Bool {
    return asbool _(tk1._1 == arg)
}

func open: (_FILE_PTR,_FILE_PTR) -> () {
    set fout = arg.1
    set finp = arg.2
    set lin = 1;
    set col = 1;
    if asbool _(finp != NULL) {
        call lexer ()
    }
}

func open_out: (_String,Int) -> () {
    var fout: _FILE_PTR = _(stropen("w", arg._2, arg._1))
    var finp: _FILE_PTR = _NULL
    return open (fout, finp)
}

func open_inp: _String -> () {
    var fout: _FILE_PTR = _NULL
    var finp: _FILE_PTR = _(stropen("r", 0, arg))
    return open (fout, finp)
}

func close: () -> () {
    if asbool _(fout != NULL) {
        call _fclose fout
    }
    if asbool _(finp != NULL) {
        call _fclose finp
    }
}

-------------------------------------------------------------------------------

type pre Type

type rec List_Type {                        -- CE2: generic
    Item_Type: (Type, List_Type)
}

type rec Type {                             -- CE2: subtype isrec=Bool
    Type_Any:   Bool
    Type_Unit:  Bool
    Type_Nat:   (Bool, (Int,TK_Val,Int,Int))
    Type_User:  (Bool, (Int,TK_Val,Int,Int))
    Type_Tuple: (Bool, List_Type)
    Type_Func:  (Bool, Type, Type)
}

type Maybe_Type {                           -- CE2: generic
    None_Type: ()
    Some_Type: Type
}

func parser_type: () -> Maybe_Type {
--native _{ printf(">>> %d\n", tk1._1); }

    func one: () -> Maybe_Type {
        var isalias: Bool = call accept _('\\')

        -- TYPE_UNIT
        if accept _TK_UNIT {
            return Some_Type Type_Unit isalias
        }

        -- TYPE_NATIVE
        if accept _TX_NAT {
            return Some_Type Type_Nat (isalias, tk0)
        }

        -- TYPE_PARENS / TYPE_TUPLE
        if accept_err _{'('} {
            var tmp: Maybe_Type = call parser_type ()
            if tmp.None_Type? {
                return None_Type
            }

            -- TYPE_PARENS
            if accept _{')'} {
                return tmp
            }
            if not accept_err _(',') {
                return None_Type
            }

            -- TYPE_TUPLE   // CE2: generic w/ EXPR_TUPLE
            var lst: List_Type = Item_Type (tmp.Some_Type!, $List_Type)
            {
                var cur: \List_Type = \lst.Item_Type!.2
                loop {
                    var tmp: Maybe_Type = call parser_type ()
                    if tmp.None_Type? {
                        return None_Type
                    }
                    set cur\ = Item_Type (tmp.Some_Type!, $List_Type)
                    set cur = \cur\.Item_Type!.2
                    if not accept_err _(',') {
                        break
                    }
                }
            }

            if not accept_err _{')'} {
                return None_Type
            }

            return Some_Type Type_Tuple (isalias,lst)
        }

        call err_expected _("type")
        return None_Type
    }

    var ret: Maybe_Type = call one ()
    if ret.None_Type? {
        return ret
    } else {
        -- TYPE_FUNC
        if accept _TK_ARROW {
            var out: Maybe_Type = call parser_type ()
            if out.None_Type? {
                return None_Type
            } else {
                return Some_Type Type_Func (False,ret.Some_Type!,out.Some_Type!)
            }
        } else {
            return ret
        }
    }
}

-------------------------------------------------------------------------------

type pre Expr

type rec List_Expr {
    Item_Expr: (Expr, List_Expr)
}

type rec Expr {                             -- CE2: subtype isrec=Bool
    Expr_Unit:  (Int,TK_Val,Int,Int)
    Expr_Unk:   (Int,TK_Val,Int,Int)
    Expr_Nat:   (Int,TK_Val,Int,Int)
    Expr_Empty: (Int,TK_Val,Int,Int)
    Expr_Int:   (Int,TK_Val,Int,Int)
    Expr_Var:   (Int,TK_Val,Int,Int)
    Expr_Upref: Expr
    Expr_Dnref: Expr
    Expr_Tuple: List_Expr
    Expr_Index: (Expr,(Int,TK_Val,Int,Int))
    Expr_Call:  (Expr,Expr)
    Expr_Cons:  ((Int,TK_Val,Int,Int),Expr)
    Expr_Disc:  (Expr,(Int,TK_Val,Int,Int))
    Expr_Pred:  (Expr,(Int,TK_Val,Int,Int))
}

type Maybe_Expr {
    None_Expr: ()
    Some_Expr: Expr
}

func pre parser_expr: Bool -> Maybe_Expr

func parser_expr_: () -> Maybe_Expr {
    -- EXPR_UNIT
    if accept _TK_UNIT {
        return Some_Expr Expr_Unit tk0
    }

    -- EXPR_UNK
    if accept _('?') {
        return Some_Expr Expr_Unk tk0
    }

    -- EXPR_EMPTY
    if accept _TX_EMPTY {
        return Some_Expr Expr_Empty tk0
    }

    -- EXPR_INT
    if accept _TX_NUM {
        return Some_Expr Expr_Int tk0
    }

    -- EXPR_VAR
    if accept _TX_VAR {
        return Some_Expr Expr_Var tk0
    }

    -- EXPR_NATIVE
    if accept _TX_NAT {
        return Some_Expr Expr_Nat tk0
    }

    -- EXPR_UPREF
    if accept _('\\') {
        var tk: (Int,TK_Val,Int,Int) = tk0
        var e: Maybe_Expr = parser_expr False
        if e.None_Expr? {
            return None_Expr
        }
        var ok: Bool = or (e.Some_Expr!.Expr_Nat?,
                       or (e.Some_Expr!.Expr_Var?,
                       or (e.Some_Expr!.Expr_Index?, False)))
                       --or (e.Some_Expr!.Expr_Disc?, False)))))))
        if ok {
            return Some_Expr Expr_Upref e.Some_Expr!
        } else {
            var str: _String = _("unexpected operand to `\\´")
            call err_tk (tk0,str)
            return None_Expr
        }
    }

    -- EXPR_PARENS / EXPR_TUPLE
    if accept _{'('} {
        var e: Maybe_Expr = parser_expr False
        if e.None_Expr? {
            return None_Expr
        }

        -- EXPR_PARENS
        if accept _{')'} {
            return e
        }
        if not accept_err _(',') {
            return None_Expr
        }

        -- EXPR_TUPLE
        var lst: List_Expr = Item_Expr (e.Some_Expr!, $List_Expr)
        {
            var cur: \List_Expr = \lst.Item_Expr!.2
            loop {
                var tmp: Maybe_Expr = parser_expr False
                if tmp.None_Expr? {
                    return None_Expr
                }
                set cur\ = Item_Expr (tmp.Some_Expr!, $List_Expr)
                set cur = \cur\.Item_Expr!.2
                if not accept_err _(',') {
                    break
                }
            }
        }

        if not accept_err _{')'} {
            return None_Expr
        }
        return Some_Expr Expr_Tuple lst
    }

    -- EXPR_CONS
    if accept _TX_USER {
        var sub: (Int,TK_Val,Int,Int) = tk0
        var e: Maybe_Expr = parser_expr False
        if e.None_Expr? {
            var tk: (Int,TK_Val,Int,Int) = tk1
            set tk.1 = _TK_UNIT
            set e = Some_Expr Expr_Unit tk
        }
        return Some_Expr Expr_Cons (sub,e.Some_Expr!)
    }

    call err_expected _("expression")
    return None_Expr
}

func parser_expr: Bool -> Maybe_Expr {
    var ispre: Bool = and (arg, accept _TK_CALL)

    var ret: Maybe_Expr = parser_expr_ ()
    if ret.None_Expr? {
        return None_Expr
    }

    -- EXPR_INDEX / EXPR_DISC / EXPR_PRED / EXPR_CALL
    loop {                                              -- CE2: continue
        var tk_bef: (Int,TK_Val,Int,Int) = tk0

        if accept _('.') {
            -- EXPR_INDEX
            if accept _TX_NUM {
                var tmp: Expr = Expr_Index (ret.Some_Expr!,tk0)
                set ret = Some_Expr tmp
            } else {
                if or (accept _TX_USER, accept _TX_EMPTY) {
                    var tk: (Int,TK_Val,Int,Int) = tk0
                    if accept _('?') {
                        var tmp: Expr = Expr_Pred (ret.Some_Expr!,tk)
                        set ret = Some_Expr tmp
                    } else {
                        if accept _('!') {
                            var tmp: Expr = Expr_Disc (ret.Some_Expr!,tk)
                            set ret = Some_Expr tmp
                        } else {
                            call err_expected _("`?´ or `!´")
                            return None_Expr
                        }
                    }
                } else {
                    call err_expected _("index or subtype")
                    return None_Expr
                }
            }
        } else {
            if accept _('\\') {
                -- EXPR_DNREF
                var ok: Bool = or (ret.Some_Expr!.Expr_Nat?,
                               or (ret.Some_Expr!.Expr_Var?,
                               or (ret.Some_Expr!.Expr_Upref?,
                               or (ret.Some_Expr!.Expr_Dnref?,
                               or (ret.Some_Expr!.Expr_Index?,
                               or (ret.Some_Expr!.Expr_Call?, False))))))
                               --or (ret.Some_Expr!.Expr_Disc?, False)))))))
                if ok {
                    var tmp: Expr = Expr_Dnref ret.Some_Expr!
                    set ret = Some_Expr tmp
                } else {
                    var str: _String = _("unexpected operand to `\\´")
                    call err_tk (tk0,str)
                    return None_Expr
                }
            } else {
                -- EXPR_CALL
                var ok: Bool = False
                if or (ret.Some_Expr!.Expr_Var?, ret.Some_Expr!.Expr_Nat?) {
                    var tk_bef: (Int,TK_Val,Int,Int) = tk0
                    var e: Maybe_Expr = parser_expr False
                    if e.Some_Expr? {
                        var tmp: Expr = Expr_Call (ret.Some_Expr!, e.Some_Expr!)
                        set ret = Some_Expr tmp
                        set ok = True
                    }
                }

                if not ok {
                    if asbool _(tk_bef._3==tk0._3 && tk_bef._4==tk0._4) {
                        break               -- nothing extra read: OK!
                    } else {
                        return None_Expr    -- extra token read:   NO!
                    }
                }
            }
        }
    }

    return ret
}

-------------------------------------------------------------------------------

type rec List_Sub {
    Item_Sub: (((Int,TK_Val,Int,Int),Type), List_Sub)
}

type Maybe_Sub {
    None_Sub: ()
    Some_Sub: ((Int,TK_Val,Int,Int), Type)
}

type pre Maybe_Stmt

type rec Stmt {
    Stmt_Pass:  ()
    Stmt_Var:   ((Int,TK_Val,Int,Int), Type, Expr)
    Stmt_Set:   (Expr,Expr)
    Stmt_User:  (Bool, (Int,TK_Val,Int,Int), List_Sub)
    Stmt_Call:  Expr
    Stmt_Seq:   (Stmt,Stmt)
    Stmt_Block: Stmt
    Stmt_If:    (Expr,Stmt,Stmt)
    Stmt_Func:  ((Int,TK_Val,Int,Int), Type, Maybe_Stmt)
    Stmt_Ret:   Expr
    Stmt_Nat:   (Bool,(Int,TK_Val,Int,Int))
    Stmt_Loop:  Stmt
    Stmt_Break: ()
}

type rec Maybe_Stmt {
    None_Stmt: ()
    Some_Stmt: Stmt
}

func pre parser_stmts: _TK -> Maybe_Stmt

func parser_stmt: () -> Maybe_Stmt {
    --var tk_pre: (Int,TK_Val,Int,Int) = tk0

    func parser_block: () -> Maybe_Stmt {
        if not accept_err _('{') {
            return None_Stmt
        }
        var ret: Maybe_Stmt = call parser_stmts _('}')
        if ret.None_Stmt? {
            return None_Stmt
        }
        if not accept_err _('}') {
            return None_Stmt
        }
        return Some_Stmt Stmt_Block ret.Some_Stmt!
    }

    -- STMT_VAR
    if accept _TK_VAR {
        if not accept_err _TX_VAR {
            return None_Stmt
        }
        var tk_id: (Int,TK_Val,Int,Int) = tk0
        if not accept_err _(':') {
            return None_Stmt
        }
        var tp: Maybe_Type = parser_type ()
        if tp.None_Type? {
            return None_Stmt
        }
        if not accept_err _('=') {
            return None_Stmt
        }
        var e: Maybe_Expr = parser_expr True
        if e.None_Expr? {
            return None_Stmt
        }
        return Some_Stmt Stmt_Var (tk_id,tp.Some_Type!,e.Some_Expr!)
    }

    -- STMT_SET
    if accept _TK_SET {
        var dst: Maybe_Expr = call parser_expr False
        if dst.None_Expr? {
            return None_Stmt
        }
        if not accept_err _('=') {
            return None_Stmt
        }
        var src: Maybe_Expr = call parser_expr True
        if src.None_Expr? {
            return None_Stmt
        }
        return Some_Stmt Stmt_Set (dst.Some_Expr!,src.Some_Expr!)
    }

    -- STMT_USER
    if accept _TK_TYPE {
        if not accept _TX_USER {
            return None_Stmt
        }

        var ispre: Bool = accept _TK_PRE
        var isrec: Bool = accept _TK_REC
        var tk_id: (Int,TK_Val,Int,Int) = tk0

        if ispre {
            return Some_Stmt Stmt_User (isrec,tk_id,$List_Sub)
        }

        if not accept_err _('{') {
            return None_Stmt
        }

        -- SUBS

        func parser_sub: () -> Maybe_Sub {
            if not accept_err _TX_USER {
                return None_Sub
            }
            var tk: (Int,TK_Val,Int,Int) = tk0
            if not accept_err _(':') {
                return None_Sub
            }
            var tp: Maybe_Type = call parser_type ()
            if tp.None_Type? {
                return None_Sub
            }
            return Some_Sub (tk,tp.Some_Type!)
        }

        var sub: Maybe_Sub = call parser_sub ()
        if sub.None_Sub? {
            return None_Stmt
        }

        var subs: List_Sub = Item_Sub (sub.Some_Sub!,$List_Sub)
        {
            var cur: \List_Sub = \subs.Item_Sub!.2
            loop {
                call accept _(';')
                var nxt: Maybe_Sub = call parser_sub ()
                if nxt.None_Sub? {
                    break
                }
                set cur\ = Item_Sub (nxt.Some_Sub!,$List_Sub)
                set cur = \cur\.Item_Sub!.2
            }
        }

        if not accept_err _('}') {
            return None_Stmt
        }

        return Some_Stmt Stmt_User (isrec,tk_id,subs)
    }

    if check _TK_CALL {
        var e: Maybe_Expr = parser_expr True
        if e.None_Expr? {
            return None_Stmt
        }
        var iscall: Bool = e.Some_Expr!.Expr_Call?
        call _assert _(iscall.sub)
        return Some_Stmt Stmt_Call e.Some_Expr!
    }

    -- STMT_IF
    if accept _TK_IF {
        var tst: Maybe_Expr = call parser_expr False
        if tst.None_Expr? {
            return None_Stmt
        }

        var t: Maybe_Stmt = call parser_block ()
        if t.None_Stmt? {
            return None_Stmt
        }

        if accept _TK_ELSE {
            var f: Maybe_Stmt = call parser_block ()
            if f.None_Stmt? {
                return None_Stmt
            }
            return Some_Stmt Stmt_If (tst.Some_Expr!,t.Some_Stmt!,f.Some_Stmt!)
        } else {
            return Some_Stmt Stmt_If (tst.Some_Expr!,t.Some_Stmt!,Stmt_Pass)
        }
    }

    -- STMT_BREAK
    if accept _TK_BREAK {
        return Some_Stmt Stmt_Break
    }

    -- STMT_LOOP
    if accept _TK_LOOP {
        var blk: Maybe_Stmt = call parser_block ()
        if blk.None_Stmt? {
            return None_Stmt
        }
        return Some_Stmt Stmt_Loop blk.Some_Stmt!
    }

    -- STMT_FUNC
    if accept _TK_FUNC {
        var ispre: Bool = accept _TK_PRE
        if not accept _TX_VAR {
            return None_Stmt
        }
        var tk_id: (Int,TK_Val,Int,Int) = tk0
        if not accept _(':') {
            return None_Stmt
        }
        var tp: Maybe_Type = call parser_type ()
        if tp.None_Type? {
            return None_Stmt
        }
        if ispre {
            return Some_Stmt Stmt_Func (tk_id,tp.Some_Type!,None_Stmt)
        }
        var body: Maybe_Stmt = call parser_block ()
        if body.None_Stmt? {
            return None_Stmt
        }
        return Some_Stmt Stmt_Func (tk_id,tp.Some_Type!,body)
    }

    -- STMT_RET
    if accept _TK_RET {
        var e: Maybe_Expr = call parser_expr False
        if e.None_Expr? {
            return None_Stmt
        }
        return Some_Stmt Stmt_Ret e.Some_Expr!
    }

    -- STMT_BLOCK
    if check _('{') {
        return parser_block ()
    }

    -- STMT_NAT
    if accept _TK_NAT {
        var ispre: Bool = call accept _TK_PRE
        if not accept_err _TX_NAT {
            return None_Stmt
        }
        return Some_Stmt Stmt_Nat (ispre,tk0)
    }

    call err_expected _("statement")
    return None_Stmt
}

func enseq: (Maybe_Stmt,Maybe_Stmt) -> Maybe_Stmt {
    if arg.1.None_Stmt? {
        return arg.2
    }
    if arg.2.None_Stmt? {
        return arg.1
    }
    if arg.1.Some_Stmt!.Stmt_Pass? {
        return arg.2
    }
    if arg.2.Some_Stmt!.Stmt_Pass? {
        return arg.1
    }
    return Some_Stmt Stmt_Seq (arg.1.Some_Stmt!,arg.2.Some_Stmt!)
}

func parser_stmts: _TK -> Maybe_Stmt {
    var ret: Maybe_Stmt = Some_Stmt Stmt_Pass
    loop {
        call accept _(';')
        var tk_bef: (Int,TK_Val,Int,Int) = tk0
        var s: Maybe_Stmt = call parser_stmt ()
        if s.None_Stmt? {
            if asbool _(tk_bef._3!=tk0._3 || tk_bef._4!=tk0._4) {
                return None_Stmt    -- extra token read:   NO!
            }
            if check arg {
                break
            }
            return None_Stmt
        }
        var tmp: Maybe_Stmt = ret
        set ret = enseq (tmp,s)
    }
    return ret
}

func parser: () -> Maybe_Stmt {
    var s: Maybe_Stmt = call parser_stmt ()
    if not accept_err _TK_EOF {
        return None_Stmt
    }
    return s
}

-------------------------------------------------------------------------------

func code_expr: \Expr -> () {
    if arg\.Expr_Unit? {
    }
    return ()
}

-------------------------------------------------------------------------------

func t_lexer: () -> () {
    -- COMMENTS
    {
        set finp = _{stropen("r", 0, "--foobar")}
        {
            var c: Int = call _fgetc finp
            native _(assert(c == '-');)
            native _(ungetc(c,finp);)
        }
        {
            call lx_blanks ()
            var c: Int = call _fgetc finp
            native _(assert(c == EOF);)
        }
        call _fclose finp
    }
    {
        set finp = _{stropen("r", 0, "-- foobar")}
        set lin = 1;
        set col = 1;
        call lx_blanks ()
        native _(assert(lin == 1);)
        native _(assert(col == 10);)
        call _fclose finp
    }
    {
        set finp = _{stropen("r", 0, "-- c1\n--c2\n\n")}
        set lin = 1;
        set col = 1;
        call lx_blanks ()
        native _(assert(lin == 4);)
        native _(assert(col == 1);)
        call _fclose finp
    }

    -- SYMBOLS
    {
        set finp = _{stropen("r", 0, "( -> ,")}
        set lin = 1;
        set col = 1;
        call lexer () ; native _{assert(tk1._1 == '(');}
        call lexer () ; native _{assert(tk1._1 == TK_ARROW);}
        call lexer () ; native _{assert(tk1._1 == ',');}
        call _fclose finp
    }
    {
        set finp = _(stropen("r", 0, ": }{ :"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _(assert(tk1._1 == ':');)
        call lexer () ; native _(assert(tk1._1 == '}');)
        call lexer () ; native _(assert(tk1._1 == '{');)
        call lexer () ; native _(assert(tk1._1 == ':');)
        call _fclose finp
    }

    -- KEYWORDS
    {
        set finp = _(stropen("r", 0, "xvar var else varx type"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _(assert(tk1._1 == TX_VAR);)
        call lexer () ; native _(assert(tk1._1 == TK_VAR);)
        call lexer () ; native _(assert(tk1._1 == TK_ELSE);)
        call lexer () ; native _(assert(tk1._1 == TX_VAR);)
        call lexer () ; native _(assert(tk1._1 == TK_TYPE);)
        call _fclose finp
    }

    -- TX_VAR / TX_USER
    {
        set finp = _(stropen("r", 0, "c1\nc2 c3  \n    \nc4"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c1"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 1);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c2"));
            assert(tk1._3 == 2);
            assert(tk1._4 == 1);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c3"));
            assert(tk1._3 == 2);
            assert(tk1._4 == 4);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c4"));
            assert(tk1._3 == 4);
            assert(tk1._4 == 1);
        }
        call _fclose finp
    }
    {
        set finp = _(stropen("r", 0, "c1 C1 Ca a C"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c1"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 1);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_USER);
            assert(!strcmp(tk1._2._Str,"C1"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 4);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_USER);
            assert(!strcmp(tk1._2._Str,"Ca"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 7);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"a"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 10);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_USER);
            assert(!strcmp(tk1._2._Str,"C"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 12);
        }
        call _fclose finp
    }

    -- TX_NAT
    {
        set finp = _(stropen("r", 0, "_char _Tp"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_NAT);
            assert(!strcmp(tk1._2._Str,"char"));
        }
        call _fclose finp
    }
    {
        set finp = _(stropen("r", 0, "_{(1)} _(2+2)"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_NAT);
            assert(!strcmp(tk1._2._Str,"(1)"));
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_NAT);
            assert(!strcmp(tk1._2._Str,"2+2"));
        }
        call _fclose finp
    }

    -- TX_NUM
    {
        set finp = _(stropen("r", 0, ".1a"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == '.');
        }
        call lexer () ; native _{
            assert(tk1._1 == TK_ERR);
        }
        call _fclose finp
    }
    {
        set finp = _(stropen("r", 0, ".10"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == '.');
        }
        call lexer ()
        call _assert _(tk1._1 == TX_NUM)
        var n: Int = tk1.2.Num!
        call _assert _(n == 10)
        call _fclose finp
    }

    -- TX_EMPTY
    {
        set finp = _(stropen("r", 0, "$List"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_EMPTY);
            assert(!strcmp(tk1._2._Str,"List"));
        }
        call _fclose finp
    }
}

func t_parser_type: () -> () {
    -- ERROR
    {
        set finp = _(stropen("r", 0, "xxx"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var ok: Bool = ret.None_Type?
        call _assert _(ok.sub)
        call _assert _{!strcmp(err,"(ln 1, col 1): expected type : have \"xxx\"")}
        call _fclose finp
    }
    -- TYPE_UNIT
    {
        set finp = _(stropen("r", 0, "()"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var ok: Bool = ret.Some_Type?
        var tp: Bool = ret.Some_Type!.Type_Unit?
        call _assert _(ok.sub && tp.sub)
        call _fclose finp
    }
    -- TYPE_NATIVE
    {
        set finp = _(stropen("r", 0, "_char"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var ok: Bool = ret.Some_Type?
        var tp: Bool = ret.Some_Type!.Type_Nat?
        var id: _(char*) = ret.Some_Type!.Type_Nat!.2.2.Str!
        call _assert _(ok.sub && tp.sub)
        call _assert _(!strcmp(id,"char"))
        call _fclose finp
    }
    -- TYPE_TUPLE
    {
        call open_inp _{"((),_char)"}
        var ret: Maybe_Type = call parser_type ()
        var tup: (Bool,List_Type) = ret.Some_Type!.Type_Tuple!
        var nat: _(char*) = tup.2.Item_Type!.2.Item_Type!.1.Type_Nat!.2.2.Str!
        var ok: Bool = tup.2.Item_Type!.2.Item_Type!.2.$List_Type?
        call _assert _(ok.sub && !strcmp(nat,"char"))
        call close ()
    }
    -- TYPE_FUNC
    {
        call open_inp _{"() -> ()"}
        var ret: Maybe_Type = call parser_type ()
        var fun: (Bool,Type,Type) = ret.Some_Type!.Type_Func!
        var ok1: Bool = fun.2.Type_Unit?
        var ok2: Bool = fun.3.Type_Unit?
        call _assert _(ok1.sub && ok2.sub)
        call close ()
    }
}

func t_parser_expr: () -> () {
    -- EXPR_UNIT
    {
        call open_inp _{"()"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.Some_Expr!.Expr_Unit?
        call _assert _(ok.sub)
        call close ()
    }
    -- EXPR_VAR
    {
        call open_inp _{"x"}
        var e: Maybe_Expr = call parser_expr False
        var ok: Bool = e.Some_Expr!.Expr_Var?
        var str: _(char*) = e.Some_Expr!.Expr_Var!.2.Str!
        call _assert _(ok.sub && !strcmp(str,"x"))
        call close ()
    }
    -- EXPR_PARENS
    {
        call open_inp _{"(())"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.Some_Expr!.Expr_Unit?
        call _assert _(ok.sub)
        call close ()
    }
    {
        call open_inp _{"("}
        var e: Maybe_Expr = call parser_expr False
        var ok: Bool = e.None_Expr?
        call _assert _{ok.sub && !strcmp(err,"(ln 1, col 2): expected expression : have end of file")}
        call close ()
    }
    {
        call open_inp _{"(x"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.None_Expr?
        call _assert _{ok.sub && !strcmp(err,"(ln 1, col 3): expected `,´ : have end of file")}
        call close ()
    }
    -- EXPR_NATIVE
    {
        call open_inp _{"_x"}
        var e: Maybe_Expr = call parser_expr False
        var ok: Bool = e.Some_Expr?
        var str: _(char*) = e.Some_Expr!.Expr_Nat!.2.Str!
        call _assert _(ok.sub && !strcmp(str,"x"))
        call close ()
    }
    -- EXPR_TUPLE
    {
        call open_inp _{"((),x,"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.None_Expr?
        call _assert _{ok.sub && !strcmp(err,"(ln 1, col 7): expected expression : have end of file")}
        call close ()
    }
    {
        call open_inp _{"((),x,())"}
        var e: Maybe_Expr = call parser_expr False
        var ok: Bool = e.Some_Expr?
        var tup: List_Expr = e.Some_Expr!.Expr_Tuple!
        var ok2: Bool = tup.Item_Expr!.2.Item_Expr!.1.Expr_Var?
        call _assert _{ok.sub && ok2.sub}
        call close ()
    }
    -- EXPR_CALL
    {
        call open_inp _{"xxx ()"}
        var e: Maybe_Expr = call parser_expr True
        var cal: (Expr,Expr) = e.Some_Expr!.Expr_Call!
        var ok1: Bool = cal.1.Expr_Var?
        var ok2: Bool = cal.2.Expr_Unit?
        var str: _(char*) = cal.1.Expr_Var!.2.Str!
        call _assert _{ok1.sub && ok2.sub && !strcmp(str,"xxx")}
        call close ()
    }
    {
        call open_inp _{"call xxx ()"}
        var e: Maybe_Expr = call parser_expr True
--output std (\e)
        var cal: (Expr,Expr) = e.Some_Expr!.Expr_Call!
        var ok1: Bool = cal.1.Expr_Var?
        var ok2: Bool = cal.2.Expr_Unit?
        var str: _(char*) = cal.1.Expr_Var!.2.Str!
        call _assert _{ok1.sub && ok2.sub && !strcmp(str,"xxx")}
        call close ()
    }
    {
        call open_inp _{"f()\n()\n()"}
        var e: Maybe_Expr = call parser_expr True
        var cal: (Expr,Expr) = e.Some_Expr!.Expr_Call!
        var ok1: Bool = cal.1.Expr_Var?
        var ok2: Bool = cal.2.Expr_Unit?
        var str: _(char*) = cal.1.Expr_Var!.2.Str!
        call _assert _{ok1.sub && ok2.sub && !strcmp(str,"f")}
        call close ()
    }
    -- EXPR_CONS
    {
        call open_inp _{"True ()"}
        var e: Maybe_Expr = call parser_expr True
        var cons: ((Int,TK_Val,Int,Int),Expr) = e.Some_Expr!.Expr_Cons!
        var str: _(char*) = cons.1.2.Str!
        var ok2: Bool = cons.2.Expr_Unit?
        call _assert _{ok2.sub && !strcmp(str,"True")}
        call close ()
    }
    {
        call open_inp _{"Zz1 ((),())"}
        var e: Maybe_Expr = call parser_expr True
        var cons: ((Int,TK_Val,Int,Int),Expr) = e.Some_Expr!.Expr_Cons!
        var str: _(char*) = cons.1.2.Str!
        var ok2: Bool = cons.2.Expr_Tuple?
        call _assert _{ok2.sub && !strcmp(str,"Zz1")}
        call close ()
    }
    -- EXPR_INDEX
    {
        call open_inp _{"x.1"}
        var e: Maybe_Expr = call parser_expr True
        var idx: (Expr,(Int,TK_Val,Int,Int)) = e.Some_Expr!.Expr_Index!
        var str: _(char*) = idx.1.Expr_Var!.2.Str!
        var num: Int = idx.2.2.Num!
        call _assert _{num==1 && !strcmp(str,"x")}
        call close ()
    }
    {
        call open_inp _{"x () .10 ()"}  -- x [() .10 ~()~
        var e: Maybe_Expr = call parser_expr True
        var cal: (Expr,Expr) = e.Some_Expr!.Expr_Call!
        var idx: (Expr,(Int,TK_Val,Int,Int)) = cal.2.Expr_Index!
        var str: _(char*) = cal.1.Expr_Var!.2.Str!
        var ok: Bool = idx.1.Expr_Unit?
        var num: Int = idx.2.2.Num!
        call _assert _{ok.sub && num==10 && !strcmp(str,"x")}
        call close ()
    }
    {
        call open_inp _{"x().."}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.None_Expr?
        call _assert _{ok.sub && !strcmp(err,"(ln 1, col 5): expected index or subtype : have `.´")}
        call close ()
    }
    -- EXPR_DNREF
    {
        call open_inp _{"x\\.1"}
        var e: Maybe_Expr = call parser_expr True
        var idx: (Expr,(Int,TK_Val,Int,Int)) = e.Some_Expr!.Expr_Index!
        var dn:  Expr = idx.1.Expr_Dnref!
        var str: _(char*) = dn.Expr_Var!.2.Str!
        call _assert _{!strcmp(str,"x")}
        call close ()
    }
    {
        call open_inp _{"()\\"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.None_Expr?
        call _assert _{ok.sub && !strcmp(err,"(ln 1, col 3): unexpected operand to `\\´")}
        call close ()
    }
    -- EXPR_UPREF
    {
        call open_inp _{"\\x.1"}
        var e: Maybe_Expr = call parser_expr True
        var up: Expr = e.Some_Expr!.Expr_Upref!
        var idx: (Expr,(Int,TK_Val,Int,Int)) = up.Expr_Index!
        var str: _(char*) = idx.1.Expr_Var!.2.Str!
        call _assert _{!strcmp(str,"x")}
        call close ()
    }
    {
        call open_inp _{"\\()"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.None_Expr?
        call _assert _{ok.sub && !strcmp(err,"(ln 1, col 2): unexpected operand to `\\´")}
        call close ()
    }
    -- EXPR_UNK
    {
        call open_inp _{"?"}
        var e: Maybe_Expr = call parser_expr True
        var ok: Bool = e.Some_Expr!.Expr_Unk?
        call _assert _{ok.sub}
        call close ()
    }
    -- EXPR_EMPTY
    {
        call open_inp _{"$Nat"}
        var e: Maybe_Expr = call parser_expr True
        var str: _(char*) = e.Some_Expr!.Expr_Empty!.2.Str!
        call _assert _{!strcmp(str,"Nat")}
        call close ()
    }
    -- EXPR_INT
    {
        call open_inp _{"10"}
        var e: Maybe_Expr = call parser_expr True
        var n: Int = e.Some_Expr!.Expr_Int!.2.Num!
        call _assert _{n == 10}
        call close ()
    }
    -- EXPR_DISC
    {
        call open_inp _{"x.Item!"}
        var e: Maybe_Expr = call parser_expr True
        var disc: (Expr,(Int,TK_Val,Int,Int)) = e.Some_Expr!.Expr_Disc!
        var ok1: Bool = disc.1.Expr_Var?
        var str: _(char*) = disc.2.2.Str!
        call _assert _{ok1.sub && !strcmp(str,"Item")}
        call close ()
    }
    -- EXPR_PRED
    {
        call open_inp _{"x.Item?"}
        var e: Maybe_Expr = call parser_expr True
        var disc: (Expr,(Int,TK_Val,Int,Int)) = e.Some_Expr!.Expr_Pred!
        var ok1: Bool = disc.1.Expr_Var?
        var str: _(char*) = disc.2.2.Str!
        call _assert _{ok1.sub && !strcmp(str,"Item")}
        call close ()
    }
}

func t_parser_stmt: () -> () {
    -- STMT_VAR
    {
        call open_inp _{"var x: () = ()"}
        var s: Maybe_Stmt = call parser_stmt ()
        var ok: Bool = s.Some_Stmt?
        var str1: _(char*) = s.Some_Stmt!.Stmt_Var!.1.2.Str!
        var ok2: Bool = s.Some_Stmt!.Stmt_Var!.2.Type_Unit?
        var ok3: Bool = s.Some_Stmt!.Stmt_Var!.3.Expr_Unit?
        call _assert _{ok.sub && ok2.sub && ok3.sub && !strcmp(str1,"x")}
        call close ()
    }
    -- STMT_USER
    {
        call open_inp _{"type Bool { False:() ; True:() }"}
        var s: Maybe_Stmt = call parser_stmt ()
        var user: (Bool, (Int,TK_Val,Int,Int), List_Sub) = s.Some_Stmt!.Stmt_User!
        var str: _(char*) = user.2.2.Str!
        var tru: _(char*) = user.3.Item_Sub!.2.Item_Sub!.1.1.2.Str!
        call _assert _{!user._1.sub && !strcmp(str,"Bool") && !strcmp(tru,"True")}
        call close ()
    }
    -- STMT_CALL
    {
        call open_inp _{"call f()"}
        var s: Maybe_Stmt = call parser_stmt ()
        var cal: Expr = s.Some_Stmt!.Stmt_Call!
        var ok: Bool = cal.Expr_Call?
        var ok1: Bool = cal.Expr_Call!.1.Expr_Var?
        var ok2: Bool = cal.Expr_Call!.2.Expr_Unit?
        call _assert _{ok.sub && ok1.sub && ok2.sub}
        call close ()
    }
    {
        call open_inp _{"call _printf ()"}
        var s: Maybe_Stmt = call parser_stmt ()
        var cal: Expr = s.Some_Stmt!.Stmt_Call!
        var ok: Bool = cal.Expr_Call?
        var ok1: Bool = cal.Expr_Call!.1.Expr_Nat?
        var ok2: Bool = cal.Expr_Call!.2.Expr_Unit?
        call _assert _{ok.sub && ok1.sub && ok2.sub}
        call close ()
    }
    -- STMT_SEQ
    {
        call open_inp _{"call f() ; call _printf () ; call g()"}
        var s: Maybe_Stmt = call parser_stmts _TK_EOF
        var seq: (Stmt,Stmt) = s.Some_Stmt!.Stmt_Seq!
        {
            var cal: Expr = seq.1.Stmt_Seq!.1.Stmt_Call!
            var ok: Bool = cal.Expr_Call?
            var ok1: Bool = cal.Expr_Call!.1.Expr_Var?
            var ok2: Bool = cal.Expr_Call!.2.Expr_Unit?
            call _assert _{ok.sub && ok1.sub && ok2.sub}
        }
        {
            var cal: Expr = seq.1.Stmt_Seq!.2.Stmt_Call!
            var ok: Bool = cal.Expr_Call?
            var ok1: Bool = cal.Expr_Call!.1.Expr_Nat?
            var ok2: Bool = cal.Expr_Call!.2.Expr_Unit?
            call _assert _{ok.sub && ok1.sub && ok2.sub}
        }
        {
            var cal: Expr = seq.2.Stmt_Call!
            var ok: Bool = cal.Expr_Call?
            var ok1: Bool = cal.Expr_Call!.1.Expr_Var?
            var ok2: Bool = cal.Expr_Call!.2.Expr_Unit?
            call _assert _{ok.sub && ok1.sub && ok2.sub}
        }
        call close ()
    }
    -- STMT_BLOCK
    {
        call open_inp _{"{ call f() }"}
        var s: Maybe_Stmt = call parser_stmt ()
        var blk: Stmt = s.Some_Stmt!.Stmt_Block!
        var ok: Bool = blk.Stmt_Call?
        call _assert _{ok.sub}
        call close ()
    }
    -- STMT_IF
    {
        call open_inp _{"if () {} else { call f() }"}
        var s: Maybe_Stmt = call parser_stmt ()
        var if_: (Expr,Stmt,Stmt) = s.Some_Stmt!.Stmt_If!
        var ok: Bool = if_.1.Expr_Unit?
        var ok1: Bool = if_.2.Stmt_Block!.Stmt_Pass?
        var ok2: Bool = if_.3.Stmt_Block!.Stmt_Call?
        call _assert _{ok.sub && ok1.sub && ok2.sub}
        call close ()
    }
    -- STMT_FUNC, STMT_RET
    {
        call open_inp _{"func f : () -> () { return () }"}
        var s: Maybe_Stmt = call parser_stmt ()
        var f: ((Int,TK_Val,Int,Int),Type,Maybe_Stmt) = s.Some_Stmt!.Stmt_Func!
        var str: _(char*) = f.1.2.Str!
        var ok1: Bool = f.2.Type_Func?
        var ok2: Bool = f.3.Some_Stmt!.Stmt_Block!.Stmt_Ret?
        call _assert _{ok1.sub && ok2.sub && !strcmp(str,"f")}
        call close ()
    }
    {
        call open_inp _{"func pre f : () -> ()"}
        var s: Maybe_Stmt = call parser_stmt ()
        var f: ((Int,TK_Val,Int,Int),Type,Maybe_Stmt) = s.Some_Stmt!.Stmt_Func!
        var str: _(char*) = f.1.2.Str!
        var ok1: Bool = f.2.Type_Func?
        var ok2: Bool = f.3.None_Stmt?
        call _assert _{ok1.sub && ok2.sub && !strcmp(str,"f")}
        call close ()
    }
    -- STMT_NAT
    {
        call open_inp _{"native pre _{xxx}"}
        var s: Maybe_Stmt = call parser_stmt ()
        var nat: (Bool,(Int,TK_Val,Int,Int)) = s.Some_Stmt!.Stmt_Nat!
        var ok: Bool = nat.1
        var str: _(char*) = nat.2.2.Str!
        call _assert _{ok.sub && !strcmp(str,"xxx")}
        call close ()
    }
    -- STMT_LOOP, STMT_BREAK
    {
        call open_inp _{"loop { break }"}
        var s: Maybe_Stmt = call parser_stmt ()
        var lop: Stmt = s.Some_Stmt!.Stmt_Loop!
        var ok: Bool = lop.Stmt_Block!.Stmt_Break?
        call _assert _{ok.sub}
        call close ()
    }
    -- STMT_SET
    {
        call open_inp _{"set s = ()"}
        var s: Maybe_Stmt = call parser_stmt ()
        var ss: (Expr,Expr) = s.Some_Stmt!.Stmt_Set!
        var ok1: Bool = ss.1.Expr_Var?
        var ok2: Bool = ss.2.Expr_Unit?
        call _assert _{ok1.sub && ok2.sub}
        call close ()
    }
}

func t_code: () -> () {
    -- EXPR_UNIT
    {
        native _{ char out[256]; }
        var s: _String = _out
        call open_out (s,256)
        var enu: Int = _TK_UNIT
        var e: Expr = Expr_Unit (enu,Str _({}),0,0)
        call code_expr (\e)
        call close ()
        call _assert _{!strcmp(out,"")}
    }
}

call t_lexer  ()
call t_parser_type ()
call t_parser_expr ()
call t_parser_stmt ()
call t_code ()
